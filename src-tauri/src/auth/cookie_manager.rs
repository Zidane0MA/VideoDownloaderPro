use super::encryption::{decrypt_string, encrypt_string};
use super::extractor::UsernameExtractor;
use crate::entity::platform_session;
use chrono::Utc;

use sea_orm::{DatabaseConnection, EntityTrait, Set};
use std::path::PathBuf;
use std::sync::Arc;
use tokio::fs;
use tokio::io::AsyncWriteExt;
use uuid::Uuid;

#[derive(Debug, serde::Deserialize)]
struct CookieJson {
    domain: String,
    #[serde(default)]
    path: String,
    #[serde(default)]
    secure: bool,
    #[serde(alias = "expirationDate", alias = "expires")]
    expiration_date: Option<f64>,
    name: String,
    value: String,
}

pub struct CookieManager {
    db: Arc<DatabaseConnection>,
    temp_dir: PathBuf,
}

impl CookieManager {
    pub fn new(db: Arc<DatabaseConnection>, app_data_dir: PathBuf) -> Self {
        let temp_dir = app_data_dir.join("system").join("temp");
        // Ensure temp dir exists (in a real app, this should probably be done at startup)
        // For now we'll assume the caller handles or we handle it lazily
        Self { db, temp_dir }
    }

    /// initialize temp directory
    pub async fn init(&self) -> Result<(), std::io::Error> {
        fs::create_dir_all(&self.temp_dir).await
    }

    pub async fn set_session(
        &self,
        platform_id: String,
        mut cookies_str: String,
        method: String,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        tracing::info!(
            "Setting session for platform: {}, method: {}",
            platform_id,
            method
        );

        // Validate cookies string (basic check)
        if cookies_str.trim().is_empty() {
            tracing::warn!("Cookies string is empty for {}", platform_id);
            return Err("Cookies string is empty".into());
        }

        // Check for JSON format (starts with [ or {) and convert to Netscape
        let trimmed = cookies_str.trim();
        if trimmed.starts_with('[') || trimmed.starts_with('{') {
            tracing::info!("Detected JSON cookies, attempting conversion to Netscape format");

            // Parse as generic JSON Value first to handle different structures
            let json_value: serde_json::Value = match serde_json::from_str(trimmed) {
                Ok(v) => v,
                Err(e) => {
                    tracing::warn!("Failed to parse JSON string: {}", e);
                    return Err(format!("Invalid JSON format: {}", e).into());
                }
            };

            // Determine the list of cookies based on structure
            let cookies_list: Result<Vec<CookieJson>, String> = if json_value.is_array() {
                serde_json::from_value(json_value)
                    .map_err(|e| format!("Invalid cookie list: {}", e))
            } else if let Some(cookies_array) = json_value.get("cookies").and_then(|c| c.as_array())
            {
                tracing::info!("Detected wrapper object with 'cookies' field");
                // Clone the array content to create a new Value, avoiding borrow issues
                serde_json::from_value(serde_json::Value::Array(cookies_array.clone()))
                    .map_err(|e| format!("Invalid wrapper content: {}", e))
            } else {
                // Try single object last
                match serde_json::from_value::<CookieJson>(json_value) {
                    Ok(cookie) => {
                        tracing::info!("Detected single JSON cookie object");
                        Ok(vec![cookie])
                    }
                    Err(e) => Err(format!(
                        "Invalid JSON structure. Expected a cookie list, a wrapper object with 'cookies' list, or a valid single cookie object. Error: {}",
                        e
                    )),
                }
            };

            match cookies_list {
                Ok(json_cookies) => {
                    let mut netscape_lines = String::new();
                    netscape_lines.push_str("# Netscape HTTP Cookie File\n");
                    netscape_lines.push_str("# This file is generated by VideoDownloaderPro\n\n");

                    for cookie in json_cookies {
                        let domain = cookie.domain;
                        let flag = if domain.starts_with('.') {
                            "TRUE"
                        } else {
                            "FALSE"
                        };
                        let path = cookie.path;
                        let secure = if cookie.secure { "TRUE" } else { "FALSE" };
                        let expiration = cookie.expiration_date.unwrap_or(0.0) as i64;
                        let name = cookie.name;
                        let value = cookie.value;

                        netscape_lines.push_str(&format!(
                            "{}\t{}\t{}\t{}\t{}\t{}\t{}\n",
                            domain, flag, path, secure, expiration, name, value
                        ));
                    }
                    cookies_str = netscape_lines;
                    tracing::info!("Successfully converted JSON cookies to Netscape format");
                }
                Err(msg) => {
                    tracing::warn!("JSON conversion failed: {}", msg);
                    return Err(msg.into());
                }
            }
        }

        // Validate that the cookies actually contain the required auth tokens
        self.validate_session_cookies(&platform_id, &cookies_str)
            .await?;

        // Extract username if possible
        let mut username = UsernameExtractor::extract_from_netscape(&cookies_str, &platform_id);

        // API Fallback: If username is missing or looks like an ID, try fetching it
        if username.is_none()
            || username
                .as_ref()
                .map(|u| u.chars().all(char::is_numeric))
                .unwrap_or(false)
        {
            if platform_id == "tiktok" {
                if let Some(uid) = &username {
                    if let Some(handle) =
                        crate::auth::api::UsernameFetcher::fetch_tiktok_username(&cookies_str, uid)
                            .await
                    {
                        username = Some(handle);
                    }
                }
            } else if platform_id == "x" || platform_id == "twitter" {
                if let Some(uid) = &username {
                    if let Some(handle) =
                        crate::auth::api::UsernameFetcher::fetch_x_username(&cookies_str, uid).await
                    {
                        username = Some(handle);
                    }
                }
            }
        }

        let encrypted_data = encrypt_string(&cookies_str)?;

        let now = Utc::now();

        let session = platform_session::ActiveModel {
            platform_id: Set(platform_id.clone()),
            status: Set("ACTIVE".to_string()),
            username: Set(username),
            encrypted_cookies: Set(Some(encrypted_data)),
            cookie_method: Set(method),
            expires_at: Set(None), // TODO: Parse expiration from cookies if possible
            last_verified: Set(Some(now)),
            updated_at: Set(now),
            created_at: Set(now), // sea-orm handles ignore on update for created_at if configured, or we can query first
        };

        // Upsert implementation
        use sea_orm::sea_query::OnConflict;

        let res = platform_session::Entity::insert(session)
            .on_conflict(
                OnConflict::column(platform_session::Column::PlatformId)
                    .update_columns([
                        platform_session::Column::Status,
                        platform_session::Column::Username,
                        platform_session::Column::EncryptedCookies,
                        platform_session::Column::CookieMethod,
                        platform_session::Column::CookieMethod,
                        platform_session::Column::LastVerified,
                        platform_session::Column::UpdatedAt,
                    ])
                    .to_owned(),
            )
            .exec(self.db.as_ref())
            .await;

        match res {
            Ok(_) => {
                tracing::info!("Successfully saved session for {}", platform_id);
                Ok(())
            }
            Err(e) => {
                tracing::error!("Failed to save session for {}: {}", platform_id, e);
                Err(e.into())
            }
        }
    }

    pub async fn get_session(
        &self,
        platform_id: &str,
    ) -> Result<Option<String>, Box<dyn std::error::Error + Send + Sync>> {
        let session = platform_session::Entity::find_by_id(platform_id)
            .one(self.db.as_ref())
            .await?;

        if let Some(session) = session {
            tracing::info!("Found session for platform: {}", platform_id);
            if let Some(encrypted) = session.encrypted_cookies {
                let decrypted = decrypt_string(&encrypted)?;
                return Ok(Some(decrypted));
            } else {
                tracing::warn!(
                    "Session found for {} but encrypted_cookies is None",
                    platform_id
                );
            }
        } else {
            tracing::warn!("No session found in DB for platform: {}", platform_id);
        }
        Ok(None)
    }

    pub async fn get_netscape_cookies(
        &self,
        platform_id: &str,
    ) -> Result<Option<String>, Box<dyn std::error::Error + Send + Sync>> {
        let cookies_str = self.get_session(platform_id).await?;

        if let Some(raw_cookies) = cookies_str {
            // Basic validation: check if it looks like netscape
            if raw_cookies.contains("\t") && !raw_cookies.trim().starts_with("{") {
                return Ok(Some(raw_cookies));
            }

            // If it's JSON or other format, we might want to log it
            tracing::debug!(
                "Cookies for {} do not look like Netscape format (starts with '{{'?)",
                platform_id
            );

            // TODO: improved parsing if we support JSON cookies
            return Ok(Some(raw_cookies));
        }

        Ok(None)
    }

    pub async fn create_temp_cookie_file(
        &self,
        platform_id: &str,
    ) -> Result<Option<PathBuf>, Box<dyn std::error::Error + Send + Sync>> {
        tracing::info!("Attempting to create temp cookie file for {}", platform_id);
        if let Some(content) = self.get_netscape_cookies(platform_id).await? {
            // Ensure temp directory exists
            if let Err(e) = fs::create_dir_all(&self.temp_dir).await {
                tracing::error!("Failed to create temp directory: {}", e);
                return Err(e.into());
            }

            let filename = format!("{}_{}.txt", platform_id, Uuid::new_v4());
            let file_path = self.temp_dir.join(filename);

            let mut file = fs::File::create(&file_path).await?;
            file.write_all(content.as_bytes()).await?;

            tracing::info!("Created temp cookie file at {:?}", file_path);
            return Ok(Some(file_path));
        } else {
            tracing::warn!("Could not get netscape cookies for {}", platform_id);
        }
        Ok(None)
    }

    pub async fn cleanup_temp_file(
        &self,
        path: &PathBuf,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        if path.exists() {
            fs::remove_file(path).await?;
        }
        Ok(())
    }

    pub async fn delete_session(
        &self,
        platform_id: &str,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        platform_session::Entity::delete_by_id(platform_id.to_string())
            .exec(self.db.as_ref())
            .await?;
        Ok(())
    }

    async fn validate_session_cookies(
        &self,
        platform_id: &str,
        cookies_str: &str,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        // Parse the Netscape format to find cookie names
        // Format: domain \t flag \t path \t secure \t expiration \t name \t value
        let cookie_names: Vec<&str> = cookies_str
            .lines()
            .filter(|l| !l.trim().is_empty() && !l.starts_with('#'))
            .filter_map(|line| {
                let parts: Vec<&str> = line.split('\t').collect();
                if parts.len() >= 6 {
                    Some(parts[5]) // Name is at index 5
                } else {
                    None
                }
            })
            .collect();

        let required_cookie = match platform_id {
            "youtube" => vec!["__Secure-3PSID", "SID"], // Either is usually sufficient, prefer 3PSID
            "tiktok" => vec!["sessionid_ss", "sessionid"], // sessionid usually
            "instagram" => vec!["sessionid"],
            "x" => vec!["auth_token"],
            _ => vec![], // No validation for unknown platforms yet
        };

        if required_cookie.is_empty() {
            return Ok(());
        }

        let has_required = required_cookie
            .iter()
            .any(|&req| cookie_names.contains(&req));

        if !has_required {
            tracing::warn!(
                "Session validation failed for {}. Missing required cookie from: {:?}",
                platform_id,
                required_cookie
            );
            return Err(format!(
                "Session validation failed. Missing required authentication cookie ({:?}). Please ensure you are logged in.",
                required_cookie
            )
            .into());
        }

        Ok(())
    }
}
