use crate::auth::cookie_manager::CookieManager;
use crate::entity::platform_session;
use sea_orm::{DatabaseConnection, EntityTrait};
use std::sync::Arc;
use tauri::{Emitter, Manager, State, Window};
#[cfg(target_os = "windows")]
// use windows::core as windows_core;

#[cfg(target_os = "windows")]
#[cfg(target_os = "windows")]
use webview2_com::Microsoft::Web::WebView2::Win32::{
    ICoreWebView2GetCookiesCompletedHandler, ICoreWebView2GetCookiesCompletedHandler_Impl,
};
#[cfg(target_os = "windows")]
use windows::core::{HSTRING, Interface};

#[cfg(target_os = "windows")]
#[windows_implement::implement(ICoreWebView2GetCookiesCompletedHandler)]
pub struct CookieHandler {
    pub tx: std::sync::Mutex<Option<tokio::sync::oneshot::Sender<Result<String, String>>>>,
}

#[cfg(target_os = "windows")]
impl ICoreWebView2GetCookiesCompletedHandler_Impl for CookieHandler_Impl {
    #[allow(non_snake_case)]
    fn Invoke(
        &self,
        result: windows::core::HRESULT,
        cookie_list: windows::core::Ref<'_, webview2_com::Microsoft::Web::WebView2::Win32::ICoreWebView2CookieList>,
    ) -> windows::core::Result<()> {
        let mut tx_lock = self.tx.lock().unwrap();
        if let Some(tx) = tx_lock.take() {
            result.ok()?;

            let cookie_list = match cookie_list.ok() {
                Ok(l) => l,
                Err(_) => {
                    let err: Result<String, String> = Err("No cookie list returned".into());
                    let _ = tx.send(err);
                    return Ok(());
                }
            };

            let mut count = 0;
            unsafe { cookie_list.Count(&mut count) }?;
            
            let mut netscape_cookies = String::new();
            netscape_cookies.push_str("# Netscape HTTP Cookie File\n");
            netscape_cookies.push_str("# This file is generated by VideoDownloaderPro\n\n");

            for i in 0..count {
                let cookie = unsafe { cookie_list.GetValueAtIndex(i) }?;
                
                let mut domain = windows::core::PWSTR::null();
                unsafe { cookie.Domain(&mut domain) }?;
                
                let mut path = windows::core::PWSTR::null();
                unsafe { cookie.Path(&mut path) }?;
                
                let mut secure = Default::default();
                unsafe { cookie.IsSecure(&mut secure) }?;
                
                let mut expires = 0.0;
                unsafe { cookie.Expires(&mut expires) }?;
                
                let mut name = windows::core::PWSTR::null();
                unsafe { cookie.Name(&mut name) }?;
                
                let mut value = windows::core::PWSTR::null();
                unsafe { cookie.Value(&mut value) }?;

                let domain_str = unsafe { domain.to_string().unwrap_or_default() };
                let path_str = unsafe { path.to_string().unwrap_or_default() };
                let name_str = unsafe { name.to_string().unwrap_or_default() };
                let value_str = unsafe { value.to_string().unwrap_or_default() };
                
                unsafe {
                    windows::Win32::System::Com::CoTaskMemFree(Some(domain.as_ptr() as *const _));
                    windows::Win32::System::Com::CoTaskMemFree(Some(path.as_ptr() as *const _));
                    windows::Win32::System::Com::CoTaskMemFree(Some(name.as_ptr() as *const _));
                    windows::Win32::System::Com::CoTaskMemFree(Some(value.as_ptr() as *const _));
                }

                let flag = if domain_str.starts_with('.') { "TRUE" } else { "FALSE" };
                let secure_bool: bool = secure.into();
                let secure_str = if secure_bool { "TRUE" } else { "FALSE" };

                netscape_cookies.push_str(&format!(
                    "{}\t{}\t{}\t{}\t{}\t{}\t{}\n",
                    domain_str, flag, path_str, secure_str, expires as i64, name_str, value_str
                ));
            }
            let _ = tx.send(Ok(netscape_cookies));
        }
        Ok(())
    }
}

#[tauri::command]
pub async fn get_auth_status(
    db: State<'_, Arc<DatabaseConnection>>,
) -> Result<Vec<platform_session::Model>, String> {
    platform_session::Entity::find()
        .all(db.as_ref())
        .await
        .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn update_session(
    window: Window,
    cookie_manager: State<'_, Arc<CookieManager>>,
    platform_id: String,
    cookies_str: String,
    method: String,
) -> Result<(), String> {
    cookie_manager
        .set_session(platform_id.clone(), cookies_str, method)
        .await
        .map_err(|e| e.to_string())?;

    // Emit event to update UI
    window
        .emit("session-status-changed", &platform_id)
        .map_err(|e| e.to_string())?;

    Ok(())
}

#[tauri::command]
pub async fn delete_session(
    window: Window,
    cookie_manager: State<'_, Arc<CookieManager>>,
    platform_id: String,
) -> Result<(), String> {
    cookie_manager
        .delete_session(&platform_id)
        .await
        .map_err(|e| e.to_string())?;

    // Emit event to update UI
    window
        .emit("session-status-changed", &platform_id)
        .map_err(|e| e.to_string())?;

    Ok(())
}

#[tauri::command]
pub async fn import_from_browser(
    platform_id: String,
    browser: String,
    window: Window,
    app_handle: tauri::AppHandle,
    cookie_manager: State<'_, Arc<CookieManager>>,
) -> Result<(), String> {
    let url = match platform_id.as_str() {
        "youtube" => "https://www.youtube.com",
        "tiktok" => "https://www.tiktok.com",
        "instagram" => "https://www.instagram.com",
        "x" => "https://x.com",
        _ => return Err("Unsupported platform".into()),
    };

    let cookies_content = if browser == "webview" {
        #[cfg(target_os = "windows")]
        {
            let auth_window_label = format!("auth_{}", platform_id);
            let mut created_window = false;

            let auth_window = if let Some(w) = app_handle.get_webview_window(&auth_window_label) {
                w
            } else {
                tracing::info!("Auth window not found, creating hidden window for extraction");
                created_window = true;
                
                let app_local_data = app_handle
                    .path()
                    .app_local_data_dir()
                    .map_err(|e| e.to_string())?;
                let auth_data_dir = app_local_data.join("EBWebView_Auth");

                let w = tauri::WebviewWindowBuilder::new(
                    &app_handle,
                    &auth_window_label,
                    tauri::WebviewUrl::External(url.parse().unwrap()),
                )
                .title(format!("Login to {}", platform_id))
                .data_directory(auth_data_dir)
                .visible(false) // Hidden
                .build()
                .map_err(|e| e.to_string())?;

                // Wait for navigation/ready
                // We'll give it a moment to initialize the webview context
                tokio::time::sleep(std::time::Duration::from_millis(1000)).await;
                w
            };

            let (tx, rx) = tokio::sync::oneshot::channel();
            let tx_mutex = std::sync::Mutex::new(Some(tx));
            
            // We need to move data into the closure. 
            // URL must be HSTRING.
            let uri = HSTRING::from(url); 

            // use the window to access webview
            auth_window.with_webview(move |webview| {
                unsafe {
                    let webview_obj = webview.controller().CoreWebView2().unwrap();
                    let raw_ptr = windows::core::Interface::as_raw(&webview_obj);

                    // Cast to webview2-com ICoreWebView2_2 directly from raw pointer
                    // We assume ABI compatibility
                    // Use transmute_copy to handle bridging differing ICoreWebView2 types
                    let webview2: webview2_com::Microsoft::Web::WebView2::Win32::ICoreWebView2_2 = {
                        let unknown: webview2_com::Microsoft::Web::WebView2::Win32::ICoreWebView2 =
                            std::mem::transmute_copy(&raw_ptr);
                        unknown.cast().unwrap()
                    };
                    
                    let cookie_manager_webview = webview2.CookieManager().unwrap();
                    
                    let handler = CookieHandler { tx: tx_mutex };
                    // Coerce to the expected handler interface
                    let handler_interface: webview2_com::Microsoft::Web::WebView2::Win32::ICoreWebView2GetCookiesCompletedHandler = handler.into();
                    
                    cookie_manager_webview.GetCookies(&uri, &handler_interface).unwrap();
                }
            }).map_err(|e| format!("Failed to access webview: {}", e))?;

            // Wait for result
            let result = rx.await.map_err(|e| format!("Cookie extraction channel error: {}", e))??;

            if created_window {
                let _ = auth_window.close();
            }

            result
        }
        #[cfg(not(target_os = "windows"))]
        {
            return Err("WebView cookie extraction only supported on Windows".into());
        }
    } else {
        // External browser logic (yt-dlp)
        let ytdlp_path = crate::sidecar::get_binary_path(
            &app_handle,
            crate::sidecar::types::SidecarBinary::YtDlp,
        )
        .map_err(|e| e.to_string())?;

        let temp_cookie_path = std::env::temp_dir().join(format!(
            "cookies_{}_{}.txt",
            platform_id,
            uuid::Uuid::new_v4()
        ));

        tracing::info!("Executing yt-dlp import from browser: {}", browser);

        let output = tokio::process::Command::new(ytdlp_path)
            .arg("--cookies-from-browser")
            .arg(&browser)
            .arg("--cookies")
            .arg(&temp_cookie_path)
            .arg("--skip-download")
            .arg("--verbose")
            .arg(url)
            .output()
            .await
            .map_err(|e| format!("Failed to execute yt-dlp: {}", e))?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            if temp_cookie_path.exists() {
                let _ = tokio::fs::remove_file(&temp_cookie_path).await;
            }
            return Err(format!("Failed to import cookies: {}", stderr));
        }

        if !temp_cookie_path.exists() {
            return Err("yt-dlp did not create a cookie file.".into());
        }

        let content = tokio::fs::read_to_string(&temp_cookie_path)
            .await
            .map_err(|e| format!("Failed to read temp cookie file: {}", e))?;

        let _ = tokio::fs::remove_file(&temp_cookie_path).await;

        if content.trim().is_empty() {
            return Err("Imported cookie file was empty.".into());
        }
        content
    };

    cookie_manager
        .set_session(
            platform_id.clone(),
            cookies_content,
            format!("browser_import:{}", browser),
        )
        .await
        .map_err(|e| e.to_string())?;

    window
        .emit("session-status-changed", &platform_id)
        .map_err(|e| e.to_string())?;

    Ok(())
}

#[tauri::command]
pub async fn open_login_window(
    app_handle: tauri::AppHandle,
    platform_id: String,
) -> Result<(), String> {
    let url = match platform_id.as_str() {
        "youtube" => "https://accounts.google.com/ServiceLogin?service=youtube",
        "tiktok" => "https://www.tiktok.com/login",
        "instagram" => "https://www.instagram.com/accounts/login/",
        "x" => "https://x.com/i/flow/login",
        _ => return Err("Unsupported platform".into()),
    };

    let label = format!("auth_{}", platform_id);

    if let Some(w) = app_handle.get_webview_window(&label) {
        let _ = w.set_focus();
        return Ok(());
    }

    let app_local_data = app_handle
        .path()
        .app_local_data_dir()
        .map_err(|e| e.to_string())?;
    let auth_data_dir = app_local_data.join("EBWebView_Auth");

    tauri::WebviewWindowBuilder::new(
        &app_handle,
        &label,
        tauri::WebviewUrl::External(url.parse().unwrap()),
    )
    .title(format!("Login to {}", platform_id))
    .data_directory(auth_data_dir)
    .inner_size(480.0, 720.0)
    .build()
    .map_err(|e| e.to_string())?;

    Ok(())
}
